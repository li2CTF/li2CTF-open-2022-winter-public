# 5CR34M writeup
Даны бинарь и либса версии 2.31. В бинаре есть две значащие функции - `main()` и `work()`. Бинарь PIE, в нем нет функции, которая спавнит шелл, так что нам придется вызывать его самостоятельно. `system()` в бинаре тоже отстутствует. Значит, нам придется заспавнить шелл с помощью syscall'а или one_gadget'а.

Первый инетресный момент, бросающийся в глаза - контролируемая форматируемая строка. Она дает нам **arbitrary read** (а если все пойдет хорошо, то и **write**!).

Для начала сольем базу либсы (базу бинаря сливать смысла нету, так как в нем самом нет ничего примечательного) через форматную строку. На стеке лежит адрес возврата в функцию `__libc_start_main`. Вычтя из него относительный адрес последующей команды (когда речь идет о `__libc_start_main`, этот адрес часто называют `__libc_start_main_ret`), можно получить базу либсы. Дебагером и экспериментальным путем  выясняем, что нужный нам номер аргумента для форматной строки, который позволяет слить `__libc_start_main_ret` - 13. Засылаем `%13$p`, сливаем адрес и считаем базу.

Далее возможны два варианта. Первый - ROP-цепочка, ручной вызов сискола `sys_execve`. Второй - **one_gadget** - особый гаджет либсы, спавнящий шелл. Рассмотрим оба варианта:

---

### 1. ROP-цепочка

Лирическое отступление
ROP-цепочка - надежный, безотказный метод вызова шелла при наличии места, где можно перетереть адрес возврата. Минусами же является то, что места не всегда хватает. Однако здесь все просто, так как нет ограничений на длину цепочки.

Давайте искать гаджеты. Нужные нам:

```
0x0000000000026b72 : pop rdi ; ret
0x0000000000027529 : pop rsi ; ret
0x0000000000162866 : pop rdx ; pop rbx ; ret
0x000000000004a550 : pop rax ; ret
0x000000000002584d : syscall
```

И отдельно упомянем, что оффсетом строки "/bin/sh" в данной либсе - `0x1b75aa`

Итак, решение:
1. Засылаем "%13$p"
2. Получаем от сервера адрес `__libc_start_main_ret`, считаем базу либсы
3. Строим rop-цепочку, прибавляя ко всем относительным адресам базу
4. Наслаждаемся шеллом

---

### 2. one_gadget
Теперь посмотрим на one_gadget. Несомненным плюсом этого метода является то, что это просто, быстро, не требует много места. Минусом же является наличие условий - вангаджеты требуют выполенение определенных условий (чаще всего то, чтобы определенные регистры были 0), и, как уже понятно, с вангаджетом может просто не повезти. Однако в данном случае 1 из 3 вангаджетов работает, и мы успешно спавним шелл.

1 из 3 гаджетов работает. Итак, план:
1. Засылаем "%13$p"
2. Получаем от сервера адрес `__libc_start_main_ret`, считаем базу либсы
3. Перетираем адрес возврата one_gadget'ом
4. Наслаждаемся шеллом

---

Пример решения обоими методами в [solve_rop.py](solve_rop.py), [solve_og.py](solve_og.py)

P.S. Арт монстра взят с https://ascii.co.uk/art/monster

Флаг: `li2CTF{sCr34M1ng_15_7h3_k3y_1n_pwn,_15n'7_17???}`
